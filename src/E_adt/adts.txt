=============================== ADTs ======================================

Abstraction: omitting or hiding low-level details with a simpler,
higher-level idea.

Abstract data type: a data type that is characterized by its operations
(method headers + documentation) instead of by its internal representation.

Example: the StringBuilder ADT:
When we talk about a StringBuilder object, we don't have in mind any
specific data structure for representing a string of text. It might be an
array of chars, or an array of bytes, or something completely different.
We, as users of StringBuilder objects, don't care. Rather, a StringBuilder
is an object that satisfies the specifications of all the operations of
StringBuilder: length(), charAt(int index), etc. We don't care about how
these methods work internally or how the characters are stored in memory,
as long as the methods work correctly.

The operations of an abstract type are classified as follows:
- Creators: create new objects of the type. A creator may take values of
  other types as arguments, but not an object of the type being constructed.
  Example: new StringBuilder(), new StringBuilder(String s)
- Producers: also create new objects of the type, but require one or more
  existing objects of the type as input.
  Example: StringBuilder's substring method.
- Observers: take objects of the type and return objects of a different type.
  Example: StringBuilder's length method.
- Mutators: modify objects.
  Example: StringBuilder's append method.

Here are some examples of abstract data types, along with some of their
operations, grouped by kind.

int:
- creators: the numeric literals 0, 1, 2, ...
- producers: arithmetic operators +, -, *, /, %
- observers: comparison operators ==, !=, <, >
- mutators: none (int values are immutable)

String:
- creators: String constructors, String literals (like "abc")
- producers: concat, substring, toUpperCase
- observers: length, charAt
- mutators: none (String objects are immutable)

List: List is an interface, which means that other classes provide the actual
implementation of the data type. These classes include ArrayList and LinkedList.
- creators: new ArrayList(), new LinkedList(), List.of(...)
- producers: subList, reversed (covered later)
- observers: size, get
- mutators: add, remove, set, sort

The following are not ADTs:
- a record
- a class with public instance fields
- a class whose documentation specifies a particular internal representation
    - for example, ArrayList is not an ADT, because its documentation states
      that the elements are stored in an array. Even the name ArrayList
      indicates the internal representation.

The following are ADTs:
- an interface, such as List
- a class whose instance fields are only private and whose documentation
  does not specify a specific implementation
    - E.g., String, StringBuilder

In the current folder, there are two subfolders with examples of ADTs: distance and set.
- Distance is an ADT, but DistanceM and DistanceK are not
  (rather, they are implementations of an ADT).
- CharSet is an ADT, but StringCharSet and ArrayCharSet are not
  (rather, they are implementations of an ADT).

============================ interfaces and ADTs =================================

Java's interface is a useful language mechanism for expressing an ADT. Reasons:
1. An interface allows us to separate an ADT's specification (method headers +
   documentation, in an interface) from an ADT's concrete implementation
   (instance fields and method bodies).
2. The interface is all a client programmer needs to read to understand the ADT.
3. If the client just relies on the interface, the client can't create inadvertent
   dependencies on the ADTâ€™s internal representation, because an interface cannot
   contain instance fields.
4. Multiple different representations of one abstract data type can coexist in the
   same program, as different classes implementing the same interface.

============================ Coding to the interface ===============================

Coding to the interface: writing applications targeted to interfaces, not to
specific implementations. This makes our code more flexible, by making it
easy to switch to a different representation later.

Example:

The ArrayList class inherits from the List interface. The List interface
specifies what it means to be a List, including operations such as add,
remove, get, and set. ArrayList is the most commonly used implementation of
List. ArrayList implements (provides method bodies) for List's abstract
methods, and introduces a new method or two of its own.

Here's the recommended way to create an ArrayList:
List<String> list = new ArrayList<>();

Using List, instead of ArrayList, as the variable type is an example of
coding to the interface. It ensures that we only call List methods, and not
methods specific to ArrayList. This makes it possible later to easily switch
to another implementation of List, such as LinkedList. All we have to do is change every "new ArrayList<>()"
to "new LinkedList<>()". Since the variable type was List, not ArrayList, the
compiler makes sure that we only called methods that are available in List, and not
any methods that are unique to ArrayList.

If there's a true need to use methods that are specific to ArrayList, then we have
no choice but to use ArrayList as the type. But such a situation is very rare.